lfsr_encrypt{
    preamble{
        >(127) ^ > ^ <(127)             # fetch the seed and tap
        > _ <  _                        # place the seed and tap
        <
        call{ run_encryption }
                              
    }
    depends{
        code/bitwise.cow
    }
    namespace{
        run_encryption{
            call{setup}
        }
        setup{  # encrypt the first four bits (edge case)
            # seed and tap in +1, +2
            >>> [-] +(32)               # ascii space
            PUSH > wipe(10) POP <(10)   # set up the prefix
            <<<
            
            call{encrypt2}
            call{encrypt1}
            call{lfsr advance}          # cycle the lfsr
            
        }
        encrypt1{ # edge case encryption
            > PUSH <<< POP >> PUSH > POP > PUSH << POP  # grab an ascii space
            call{lfsr encrypt}
        }
        encrypt2{ # start at +2, on first encrypted symbol
            << PUSH > POP > PUSH << POP >>      # place the encrypted character
            > PUSH < POP                        # place seed for advancement
            < PUSH >> POP <                     # place tap for advancement

            call{encrypt3}
            call{lfsr advance}
        }
        encrypt3{
            > PUSH                              # place tap in stack
            < PUSH > POP > PUSH << POP          # position chars for encryption
            
            call{full_encrypt}
            call{lfsr encrypt}
        }
        full_encrypt{
            PUSH < POP                          # place encrypted character
            >> PUSH < POP >> PUSH < POP         # prep a char for encryption
            EXIT
        }
        place_message{
            +(32) # ascii space
            PUSH(15)
            rightAndPop(15)
            <(15)
        }
        lfsr imports bitwise binds bitwise{
            start{
                call{advance}
            }
            encrypt{ # value to encrypt in +0, seed in +1
                call{bitwise xor}
            }
            advance{ # seed in +0, tap pattern in +1
                PUSH                    # save the seed
                prep_expand

                call{apply_tap}
                call{bitwise double_expand}
            }
            apply_tap{
                >>>> # move to start of bit pairs
                bit_and(8)
                finish_advance
                < POP >
                PUSH < POP              # store the result in the control cell
                > POP [-<++>]           # double original value into -1 (shleft)
                < PUSH > POP            # copy cc value into +0
            }
        }
    }
    bindings{
        rightAndPop{
            > POP
        }
        toggle_xor{
            # start:    v
            # | zero | AND | toggle |

            # [>[<<->>]<-]>[<<+>>-]<<
            [->-<]>[<<+>> ZERO ]<<<
        }
        finish_advance{
            <                       # end of last pair
            <<                      # last pair result
            # EXIT
            toggle_xor(7)
            > PUSH <<<< POP         # place the result in +0
            >(19) lrestore(19)      # restore saved cells
            < PUSH >                
        }
        wipe{
            _^>
        }
    }
    postamble{

    }
}