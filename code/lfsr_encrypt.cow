lfsr_encrypt{
    preamble{
        >(127) ^ > ^ <(127)             # fetch the seed and tap
        > _ <  _                        # place the seed and tap
        <
        call{ run_encryption }
                              
    }
    depends{
        code/bitwise.cow
    }
    namespace{
        run_encryption{
            >
            call{main}
            call{lfsr advance}
        }
        main{  # encrypt remaining message
            # seed and tap in +1, +2
            #     -2     -1     +0     +1     +2
            #  | ZERO |  CC  | NONE | SEED | TAP  |
            <
            > PUSH > PUSH >> POP < POP <
            >>> [-] +(32)               # ascii space
            PUSH > wipe(8) POP <(8)     # set up the prefix
            <<<                         # in +1
            < ZERO +(60) PUSH           # loop 10 times
            >> PUSH                     # grab the tap in +2
            < PUSH                      # grab seed in +1
            >> PUSH << POP              # place next value in +1
            > POP                       # seed in +2
            <                           # rebase to +1
            
            call{ lfsr kickstart }                       
            
        }
        lfsr imports bitwise binds bitwise{
            kickstart{
                < POP >
                call{encrypt_loop}
                call{encrypt}
            }
            transition{ # incoming: seed in +0, tap in +1
                #    -4     -3      -2     -1     +0     +1     +2
                # | DONE | COUNT | ZERO |  CC  | SEED | TAP  | NEXT |
                
                > PUSH                  # grab the tap
                > PUSH < POP            # move the next value into +1 position
                < PUSH >> POP           # place the seed in +2 for encryption
                <<< POP                 # tap in -1
                << PUSH                 # push COUNT to stack
                >> PUSH                 # push tap to stack
                < PUSH >> POP           # zero SEED cell
                >                       # position in +1 to shift frame

                call{encrypt_loop}
                call{encrypt}
            }
            encrypt_loop{ # value to encrypt at +0
                # stack: ... COUNT TAP
                #    -4     -3       -2     -1     +0     +1     +2
                # | TARG | FREE1 | FREE2 |  CC  | DONE | SEED | ---- |
                # advance lfsr
                # encrypt byte
                # how to maneuver everything with limited space

                PUSH <(4) POP           # place encrypted byte in TARG
                >(4) POP                # tap in DONE
                <(3) POP PUSH           # counter in FREE1
                >(1) POP                # counter in FREE2
                [
                    <->                 # decrement counter
                    >>
                    call{ transition }
                    call{ advance }
                    <<                  # clear dup counter in FREE2 to break
                    ZERO
                ]
                # shuffle things around for lfsr advance
                # target config:
                # |  CC  | SEED | TAP  |
                >>                      # move into DONE (tap is here)
                PUSH < POP >> PUSH < POP < PUSH >> POP <
                # ready for lfsr advancement
            }
            encrypt{ # value to encrypt in +0, seed in +1
                #     v
                # | VALUE | SEED  |

                call{bitwise xor}

                # result: encrypted in +0, seed in +1
                # | DONE  | SEED  |
                #     ^
            }
            advance{ # seed in +0, tap pattern in +1
                PUSH                    # save the seed
                prep_expand

                call{apply_tap}
                call{bitwise double_expand}
                # result: new seed in +0, tap in +1
            }
            apply_tap{
                >>>> # move to start of bit pairs
                bit_and(8)
                finish_advance
                < POP >
                PUSH < POP              # store the result in the control cell
                > POP [-<++>]           # double original value into -1 (shleft)
                < PUSH > POP            # copy cc value into +0
            }
        }
    }
    bindings{
        rightAndPop{
            > POP
        }
        toggle_xor{
            # start:    v
            # | zero | AND | toggle |

            # [>[<<->>]<-]>[<<+>>-]<<
            [->-<]>[<<+>> ZERO ]<<<
        }
        finish_advance{
            <                       # end of last pair
            <<                      # last pair result
            # EXIT
            toggle_xor(7)
            > PUSH <<<< POP         # place the result in +0
            >(19) lrestore(19)      # restore saved cells
            < PUSH >                
        }
        wipe{
            _^>
        }
    }
    postamble{

    }
}