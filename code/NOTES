################################################################################
NOTES COMPILER/EMULATOR
################################################################################
* namespaces with nested namespaces of the same name produce errors
    * occurred when importing module bitwise into namespace bitwise
* function bodies without dependencies in importing namespaces case KeyError
* invalid inline closure detection doesnt always work "cal{fn}" causes a 
    KeyError in the _NAME_ tag

################################################################################
NOTES ON CODING STYLE
################################################################################

* rails: working with variable-sized data structures if often best achieved 
    using "rails", which are dead memory areas filled with 1's, bounded on both 
    sides by a zero. These regions can be traversed by a simple [>], so code can
    be written to traverse by regions instead of by individual cell.
    * rail creation: rails can be created by hand if their length is known at 
        compile time, or they can be generated by a rail-laying function, which
        carries a counter with it that allows rail length to be a value in
        memory. Rails can also be laid until some memory condition is satisfied,
        such as encountering a nonzero cell.
    * rail traversal: rails are extremely easy to traverse (as long as you only 
        go end-to-end) using [>] or [<], which allows functions to compactly
        reposition to other memory locations without expensive recursive
        travelling functions or hardcoded values.
    * data: data can be used as rails if it is known to be nonzero. Otherwise, a 
        data rail should be used, which makes use of alternating 1's with data.
        Data rails can be traversed with [>>], and can store arbitrary 
        data. 
    * functions: recursive functions can make use of rails since they are a
        known value, allowing them to safely and atomically traverse rails. This
        can be used to operate on railed data without needing to account for
        the data clobbering that traveller functions do. One application of this
        is the use of a traveller function to segment existing rails, allowing
        for abstractions such as "memory allocation" by cutting new regions into
        an existing rail line.

* namespace hiding: functions written in COW must often modify the stack and 
    otherwise alter normal program flow in order to achieve the desired result.
    One side effect of this is functions which must be called in a specific
    order, as they rely on non-standard stack behavior executed in related code.
    These non-atomic functions should not be exposed in the base namespace.
    Multi-part function executions should be hidden in nested namespaces and 
    called upon by functions in the base namespace, which allows modules to 
    make use of non-atomic behavior without exposing non-atomic components to
    importing modules.
    * An example of this behavior can be found below, in which a self-calling
        function crams data onto the stack. Importing modules should not have to
        wrangle this behavior directly. Instead, a caller function is exposed in 
        the base namespace, which creates a workspace for the recursor. The 
        function performing most of the work is hidden, along with its cleanup 
        routine, in a nested namespace, preventing calling modules from directly
        accessing sensitive functions.


Apply function to specified number of adjacent cells
* self-calling function that carries a loop condition along with it 
* hides data underneath the call stack
* cleanup function writes results back to cells

loopTemplate{           # recursive "for" loop -> apply fn to adjacent cells
    # we expect the loop counter to be in the cell we start in
    > ATOMIC_OP PACK        # do some atomic evaluation, cram result onto stack
    < rcopy                 # copy counter into cell we extracted
    -^[                     # call the next block if counter is nonzero
        _                   # unpack
        call{loopTemplate}  # overwrites old counter
        ^[-]                # (exit)
    ]_                      # unpack counter into current cell
    PUSH NOT [              # run this loop if the counter is zero
        POP                 # pop the zero -> overwrite entry condition
        call{loopCleaner}   # run the cleanup function
        PUSH                # replace the zero
    ] POP                   # restore the value we NOTed
}

loopCleaner{
    rUNPACK(8)
}

binding rUNPACK { < UNPACK  }
binding PACK    {   PUSH    }

################################################################################
NOTES ON TASKS
################################################################################
* recursive encryption loop:
    * counter, seed, tap
    * values on stack
    * counter on stack
1. counter in free space, decrement
2. 
                  v
| -3 | -2 | -1 | +0 | +1 | +2 |
 FREE FREE  CC  SEED NEXT
