################################################################################
NOTES COMPILER/EMULATOR
################################################################################
* namespaces with nested namespaces of the same name produce errors
    * occurred when importing module bitwise into namespace bitwise
* function bodies without dependencies in importing namespaces case KeyError
* invalid inline closure detection doesnt always work "cal{fn}" causes a 
    KeyError in the _NAME_ tag

################################################################################
NOTES ON CODING STYLE
################################################################################

* rails: working with variable-sized data structures if often best achieved 
    using "rails", which are dead memory areas filled with 1's, bounded on both 
    sides by a zero. These regions can be traversed by a simple [>], so code can
    be written to traverse by regions instead of by individual cell.
    * rail creation: rails can be created by hand if their length is known at 
        compile time, or they can be generated by a rail-laying function, which
        carries a counter with it that allows rail length to be a value in
        memory. Rails can also be laid until some memory condition is satisfied,
        such as encountering a nonzero cell. One particularly powerful 
        application of rails is as a data reading tool, allowing programs to 
        process input in memory byte-by-byte by laying rails as data is consumed
    * rail traversal: rails are extremely easy to traverse (as long as you only 
        go end-to-end) using [>] or [<], which allows functions to compactly
        reposition to other memory locations without expensive recursive
        travelling functions or hardcoded values.
    * data: data can be used as rails if it is known to be nonzero. Otherwise, a 
        data rail should be used, which makes use of alternating 1's with data.
        Data rails can be traversed with [>>], and can store arbitrary 
        data. 
    * functions: recursive functions can make use of rails since they are a
        known value, allowing them to safely and atomically traverse rails. This
        can be used to operate on railed data without needing to account for
        the data clobbering that traveller functions do. One application of this
        is the use of a traveller function to segment existing rails, allowing
        for abstractions such as "memory allocation" by cutting new regions into
        an existing rail line.

* memory manager: using rails, we can implement a memory management system with
   rich features such as indexing, and allocation
    * create: create a memory management instance at the current location.
        Requires a moderate amount of free memory, can be passed arguments
        specifying how large the initial memory should be and how it should be
        created
    * allocate: segments the memory management rail, creating a free space 
        of the specified size. Updates the manager's memory table to reflect
        the allocation. Returns to the caller's memory index, and writes the
        memory index of the allocated zone to the caller's arg section
        * allocated memory has a number of sections:
            * before and after the allocation are data rails which help direct
                memory traversals over the region, contiaining information such
                as the zone ID and size
            * at the low memory index of the allocated region is the messaging
                space, which is where memory calls should originate and where
                function call arguments should be placed
    * free: removes an entry from the reserved memory table. The manager will
        not wipe or remove memory that is free'd unless it is needed by another
        allocation.
    * goto: use the memory manager to relocate the data head to another zone.
        The caller should load the stack with a reciever function that will
        be passed control after the goto routine completes. The goto routine
        will complete in the messaging section of the given zone, unless
        an error occurred and the request could not be completed
        * cautious memory traversal: 
            * initiated by user-generated memory traversal calls, uses zone 
                annotations to traverse towards manager zone with request data
            * chainer-style function, runs until it reaches the manager zone
                then dumps request data
        * quick memory traversal:
            * initiated by the memory manager, does not use zone annotations
            * manager can preload call stack using information from the memory
                table, allowing it to avoid using chainer functions

* namespace hiding: functions written in COW must often modify the stack and 
    otherwise alter normal program flow in order to achieve the desired result.
    One side effect of this is functions which must be called in a specific
    order, as they rely on non-standard stack behavior executed in related code.
    These non-atomic functions should not be exposed in the base namespace.
    Multi-part function executions should be hidden in nested namespaces and 
    called upon by functions in the base namespace, which allows modules to 
    make use of non-atomic behavior without exposing non-atomic components to
    importing modules.
    * An example of this behavior can be found below, in which a self-calling
        function crams data onto the stack. Importing modules should not have to
        wrangle this behavior directly. Instead, a caller function is exposed in 
        the base namespace, which creates a workspace for the recursor. The 
        function performing most of the work is hidden, along with its cleanup 
        routine, in a nested namespace, preventing calling modules from directly
        accessing sensitive functions.


Apply function to specified number of adjacent cells
* self-calling function that carries a loop condition along with it 
* hides data underneath the call stack
* cleanup function writes results back to cells

loopTemplate{           # recursive "for" loop -> apply fn to adjacent cells
    # we expect the loop counter to be in the cell we start in
    > ATOMIC_OP PACK        # do some atomic evaluation, cram result onto stack
    < rcopy                 # copy counter into cell we extracted
    -^[                     # call the next block if counter is nonzero
        _                   # unpack
        call{loopTemplate}  # overwrites old counter
        ^[-]                # (exit)
    ]_                      # unpack counter into current cell
    PUSH NOT [              # run this loop if the counter is zero
        POP                 # pop the zero -> overwrite entry condition
        call{loopCleaner}   # run the cleanup function
        PUSH                # replace the zero
    ] POP                   # restore the value we NOTed
}

loopCleaner{
    rUNPACK(8)
}

binding rUNPACK { < UNPACK  }
binding PACK    {   PUSH    }

################################################################################
NOTES ON TASKS
################################################################################
* recursive encryption loop:
    * counter, seed, tap
    * values on stack
    * counter on stack
1. counter in free space, decrement
2. 
                  v
| -3 | -2 | -1 | +0 | +1 | +2 |
 FREE FREE  CC  SEED NEXT
