#!/usr/bin/env python2.7
"""
    Proper CFG parser
"""
from __future__ import print_function
import sys
import pprint as pp

class Grammar:
    def __init__(self,nonterminals,terminals,rules,start):
        self.start          = start
        self.nonterminals   = set(nonterminals)
        self.terminals      = set(terminals)
        self.rules          = dict([(rule.symbol,rule) for rule in rules])
        self.start          = start

        if not self.start in self.nonterminals:
            parse_error("Invalid start variable: {}".format(self.start))

class Derivation:
    def __init__(self,symbols):
        self.symbol = None
        self.symbols = symbols
        self.is_nullable = None

    def nullable(self,rules,pending):
        if self.is_nullable == None:
            self.is_nullable = all(self._nullables(rules,pending))
        return self.is_nullable
    def _nullables(self,rules,pending):
        for symbol in self.symbols:
            if symbol.symbol not in pending:
                yield symbol.nullable(rules,pending)


class Nonterminal:
    def __init__(self,symbol):
        self.symbol = symbol
        self.is_nullable = None

    def nullable(self,rules,pending):
        if self.is_nullable == None:
            if self.symbol not in rules:
                parse_error("No rule for nonterminal: " + self.symbol)
            pending.add(self.symbol)
            self.is_nullable = any(rules[self.symbol]._nullables(rules,pending))
        return self.is_nullable

class Rule:
    def __init__(self,symbol,derivations):
        self.symbol      = symbol
        self.derivations = derivations
        for derivation in self.derivations:
            derivation.symbol = self.symbol
    def _nullables(self,rules,pending):
        if not self.derivations:
            parse_error("Nonterminal has no derivations: "+self.symbols)
        for derivation in self.derivations:
            yield derivation.nullable(rules,pending)

class Terminal:
    def __init__(self,symbol):
        self.symbol = symbol
    def nullable(self,rules,pending):
        return False

class Epsilon: # we might not need this
    def nullable(self,rules,pending):
        return True

# produce a dictionary(variable->terminal) of the first terminals in strings
# generated by each variable
def first(rules):
    pass

# produce a set(variable) of variables that can generate the empty string
# walk through derivations, using the start variable as entry point
def nullable(grammar):
    nullables = set()
    for nonterm in grammar.nonterminals:
        if nonterm.nullable(grammar.rules,set()):
            nullables.add(nonterm.symbol)
    return nullables
            
    


def follow(rules):
    pass

def main():
    start = Nonterminal("start")
    var1  = Nonterminal("var1")
    var2  = Nonterminal("var2")

    epsilon = Epsilon()

    st = Terminal("s")
    t1 = Terminal("t1")
    t2 = Terminal("t2")

    rstart = Rule(start.symbol,[
        Derivation([var1,var2]),
        Derivation([st]),
    ])

    rvar1 = Rule(var1.symbol,[
        Derivation([var2,t2]),
        Derivation([t2]),
    ])

    rvar2 = Rule(var2.symbol,[
        Derivation([var2,t1]),
        epsilon,
    ])

    g = Grammar(
        [start,var1,var2],
        [st,t1,t2],
        [rstart,rvar1,rvar2],
        start
    )

    pp.pprint(nullable(g))

def parse_error(reason):
    print("Error: {}".format(reason))
    exit(1)

if __name__ == '__main__':
    main()